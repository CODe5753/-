# Chapter 17. 냄새와 휴리스틱

## 주석
### C1: 부적절한 정보
이미 다른곳에서 다뤄지고 있는 정보는 주석으로 적절하지 못하다.(소스 형상 관리, 버그 추적, 이슈 추적 등)
주석은 코드와 설계에 기술적인 설명을 부연하는 수단

### C2: 쓸모 없는 주석
쓸모 없어질 주석은 아예 달지 않는 편이 가장 좋다.
주석은 빨리 낡기에 쓸모 없어진 주석은 재빨리 삭제하는 편이 가장 좋다.
코드와 무관하게 혼자서 따로 놀며 코드를 그릇된 방향으로 이끈다.

### C3: 중복된 주석
```java
i++; // i증가
```
코드만으로 충분한데 구구절절 설명하는 주석

```java
/**
 * @param sellRequest
 * @return
 * @throws ManagedComponentException
 */
public SellResponse beginSellItem(SellRequest sellRequest) throws Managed ComponentException
```
또 다른 하나는 함수 Signature만 달랑 기술하는 Javadoc이다.  

주석은 코드만으로 다하지 못하는 설명은 부언한다.

### C4: 성의 없는 주석
주석을 달아야 한다면 시간을 들여 최대한 가치있게 작성하고, 간결하고 명료하게 작성한다.

### C5: 주석 처리된 코드
주석으로 처리된 코드는 누군가에게 필요하거나 다른 사람이 사용할 코드라 생각하고 아무도 삭제하지 않고 넘어간다.  
또한 읽는 사람을 헷갈리게 만든다.  
따라서 주석으로 처리된 코드를 발견하면 즉각 지워버리자.  
<br>

## 환경
### E1: 여러 단계로 빌드해야 한다
빌드는 한 단계로 끝나야 한다.  
한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 한다.

### E2: 여러 단계로 테스트해야 한다
모든 단위 테스트는 한 명령으로 돌려야 한다.  
모든 테스트를 한 번에 실행하는 능력은 아주 근본적이고 아주 중요하다.  
따라서 그 방법이 빠르고, 쉽고, 명백해야 한다.  
<br>

## 함수
### F1: 너무 많은 인수
인수 개수는 작을수록 좋다.  
아예 없으면 가장 좋다.

### F2: 출력 인수
일반적으로 독자는 인수를 입력으로 간주한다.  
함수에서 뭔가의 상태를 변경해야 한다면 함수가 속한 객체의 상태를 변경한다.

### F3: 플래그 인수
boolean 인수는 함수가 여러 기능을 수행한다는 명백한 증거다.  
플래그 인수는 혼란을 초래하므로 피해야 마땅하다.

### F4: 죽은 인수
아무도 호출하지 않는 함수는 삭제한다.  
**형상 관리 시스템이 기억할테니 걱정할 필요가 없다.**  
<br>

## 일반
### G1: 한 소스 파일에 여러 언어를 사용한다
어떤 JSP 파일은 HTML, 자바, 태그 라이브러리 구문, 영어 주석, javadoc, XML, Javascript 등을 포함한다.  
다양한 언어가 포함된 것은 혼란스럽기 때문에 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다.

### G2: 당연한 동작을 구현하지 않는다
함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다.  
```java
Day day = DayDate.StringToDay(String dayName);
```
우리는 'Monday'를 Day.MONDAY로 변환할 것이라 예상한다.  
당연한 동작을 구현하지 않으면 독자는 더 이상 작성자를 신뢰할 수 없으므로 코드를 일일이 살펴보아야 한다.

### G3: 경계를 올바로 처리하지 않는다
스스로의 직관에 의존하지 말고 모든 경계 조건을 찾아내고, 모든 경계 조건을 테스트하는 테스트 케이스를 작성하라.

### G4: 안전 절차 무시
컴파일러 경고 일부를 꺼버리면 빌드가 쉬워질지 모르지만 자칫하면 끝없는 디버깅에 시달린다.  
실패하는 테스트 케이스를 일단 제껴두고 나중으로 미루는 태도는 신용카드가 공짜 돈이라는 생각만큼 위험하다.

### G5: 중복
코드에서 중복을 발견할 때마다 추상화할 기회로 간주하라.  
중복된 코드를 하위 루틴이나 다른 클래스로 분리하라.  
추상화 수준을 높였으므로 구현이 빨라지고 오류가 적어진다.  
- switch/else나 if/else 문으로 똑같은 조건을 거듭 확인하는 중복  
  - 다형성(polymorphism)으로 대체해야 한다.
- 알고리즘이 유사하나 코드가 서로 다른 중복
  - TEMPLATE METHOD, STRATEGY 패턴으로 중복을 제거

### G6: 추상화 수준이 올바르지 못하다
추상화는 저차원 상세 개념에서 고차원 일반 개념을 분리한다.
```java
public interface Stack {
    Object pop() throws EmptyException;
    void push(Object o) throws FullException;
    double percentFull();
    class EmptyException extends Exception {}
    class FullException extends Exception {}
}
```
`percentFull`함수는 추상화 수준이 올바르지 못하다.  
"꽉 찬 정도"라는 개념을 나타낼 수 없기 때문이다.  
그러므로 함수는 BoundedStack과 같은 파생 인터페이스에 넣어야 마땅하다.  
```java
stack.percentFull() < 50.0;
```
이 경우 OutOfMemoryException 예외가 절대 발생하지 않으리라 장담하지 못한다.  
  
다시 말해, 잘못된 추상화 수준은 거짓말이나 꼼수로 해결하지 못한다.  
잘못된 추상화를 임시변통으로 고치기는 불가능하다.  

### G7: 기초 클래스가 파생 클래스에 의존한다.
개념을 기초 클래스와 파생 클래스로 나누는 흔한 이유는 고차원 기초 클래스 개념을 저차원 파생 클래스 개념으로부터 분리해 **독립성을 보장하기 위해**서다.  
그러므로 기초 클래스가 파생 클래스를 사용한다면 뭔가 문제가 있다는 말이다. 
  
일반적으로 기초 클래스는 파생클래스를 아예 몰라야 마땅하다.  
기초 클래스와 파생 클래스를 다른 JAR 파일로 배포하면 변경이 시스템에 미치는 영향이 아주 작아지므로 현장에서 시스템을 유지보수하기가 한결 수월해진다.

### G8: 과도한 정보
잘 정의된 모듈은 인터페이스가 아주 작으며 많은 함수를 제공하지 않는다.  
그래서 결합도(coupling)이 낮다.  
  
클래스가 제공하는 메서드 수, 함수가 아는 변수 수, 클래스에 들어있는 인스턴스 변수 수는 작을 수록 좋다.  
  
인터페이스를 매우 작게 그리고 매우 깐깐하게 만들어라.  
정보를 제한해 결합도를 낮춰라.