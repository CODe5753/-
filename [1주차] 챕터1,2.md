**목차**
- [Chapter 1. 깨끗한 코드](#chapter-1-깨끗한-코드)
  - [나쁜 코드](#나쁜-코드)
  - [나쁜 코드로 치르는 대가](#나쁜-코드로-치르는-대가)
    - [원대한 재설계의 꿈](#원대한-재설계의-꿈)
    - [태도](#태도)
    - [원초적 난제](#원초적-난제)
    - [깨끗한 코드라는 예술?](#깨끗한-코드라는-예술)
    - [깨끗한 코드란?](#깨끗한-코드란)
      - [효율성](#효율성)
      - [가독성](#가독성)
      - [타인이 고치기 쉬운 코드(TDD)](#타인이-고치기-쉬운-코드tdd)
      - [코드를 주의깊게 작성하자](#코드를-주의깊게-작성하자)
  - [보이스카우트 규칙](#보이스카우트-규칙)
  - [객체지향의 5대 설계 원칙](#객체지향의-5대-설계-원칙)
- [Chapter 2.의미 있는 이름](#chapter-2의미-있는-이름)
  - [의도를 분명히 밝혀라](#의도를-분명히-밝혀라)
  - [그릇된 정보를 피하라](#그릇된-정보를-피하라)
  - [의미 있게 구분하라](#의미-있게-구분하라)
  - [발음하기 쉬운 이름을 사용하라](#발음하기-쉬운-이름을-사용하라)
  - [검색하기 쉬운 이름을 사용하라](#검색하기-쉬운-이름을-사용하라)
  - [인터페이스 클래스와 구현 클래스](#인터페이스-클래스와-구현-클래스)
  - [클래스 이름](#클래스-이름)
  - [메서드 이름](#메서드-이름)
  - [한 개념에 한 단어를 사용하라](#한-개념에-한-단어를-사용하라)
  - [말장난을 하지 마라](#말장난을-하지-마라)
  - [해법 영역에서 가져온 이름을 사용하라](#해법-영역에서-가져온-이름을-사용하라)
  - [문제 영역에서 가져온 이름을 사용하라](#문제-영역에서-가져온-이름을-사용하라)
  - [의미 있는 맥락을 추가하라](#의미-있는-맥락을-추가하라)
  - [불필요한 맥락을 없애라](#불필요한-맥락을-없애라)
  - [결론](#결론)
---
# Chapter 1. 깨끗한 코드

우린 더 나은 개발자가 되기 위해 이 책을 읽는다

## 나쁜 코드

- 나쁜 코드를 접한 경험이 있는가?
- 또는 나쁜 코드를 작성한 경험이 있는가?
- "나중에 손 봐야지"라고 생각한 적 있는가?
  - 그래서 나중에 수정 했는가?

> '리그오브레전드'라는 게임에서 '르블랑'이라는 캐릭터가 있다.
> 이 캐릭터는 **일정 시간 이내에** 과거의 위치로 돌아갈 수 있다.

![르블랑의 법칙](https://blog.kakaocdn.net/dn/cmhhHG/btqHQIjxcEd/tyw2N42jIv17cNKrv8vHK0/img.gif)

```
르블랑의 법칙: "나중은 결코 오지 않는다"
```

## 나쁜 코드로 치르는 대가

- 나쁜 코드가 쌓일수록 팀 생산성은 떨어짐

- 새로운 인력을 투입해도 해당 인력들은 또 다시 학습해야함

  > 생산성이 0에 근접하는건 아직 공감하지 못하겠다..

### 원대한 재설계의 꿈

- 참다참다, 코드가 너무 노답이니 관리자에게 재설계 요구
- 관리자도 생산성 바닥이란걸 부정하지 못함
- 결국 재설계 승인

### 태도

- 코드가 엉망이라 업무 예상 시간이 늘어난 경험이 있나?
- 개발자의 잘못이다.
  - WHY????
    - 요구사항은?
    - 일정은?
    - 무능한 관리자는?
  - 일정에 쫓기더라도 대다수 관리자는 `좋은 코드`를 원한다

### 원초적 난제

- 개발자는 근본적 가치에서 난제에 봉착한다
- 누구나 `나쁜 코드`가 업무 속도를 늦춘다는 사실을 안다
- **기한을 맞추기 위해**서 주먹구구식의 `나쁜 코드`를 양산할 수밖에 없다고 느낀다

> 언제나 코드를 **최대한 깨끗하게 유지하는 습관**이 기한을 맞추는 방법이다

```
JPA를 주먹구구식으로 짰다가 시연 직전에 낭패를 본 적이 있다.
코드간에 종속성이 있어, 문제를 고치는데 정말 애 먹었다.
물론 잘 수습했으나 진땀을 뺐던 기억이 새록새록하다.
```



### 깨끗한 코드라는 예술?

- "나쁜 코드가 심각한 장애물이다", "빨리 가려면 코드를 깨끗하게 유지해야한다" 이 두 사실을 인정한다고 가정하자.
- 자, 그럼 "**어떻게** 깨끗하게 작성할 것인가?"
- 깨끗한 코드가 무엇인지 모르면 깨끗한 코드를 만들려고 애써봤자 소용이 없다

### 깨끗한 코드란?

- 프로그래머 수만큼 정의도 다양하다

#### 	효율성

```
1. 논리가 간단해야 버그가 숨어들지 못한다
2. 의존성을 최대한 줄여야 유지보수가 쉬워진다
3. 오류는 명백한 전략에 의거해 철저히 정리한다 
4. 성능을 최적으로 유지해야 한다
```

```
논리와 버그의 상관관계를 모르겠다.
```



#### 	가독성

```
1. 단순하고 직접적이다
2. 깨끗한 설계자의 의도를 숨기지 않는다
3. 명쾌한 추상화와 단순한 제어문으로 가득하다
```



#### 	타인이 고치기 쉬운 코드(TDD)

```
1. 단위 테스트 케이스와 인수 테스트 케이스
2. 의미 있는 네이밍
3. 의존성은 최소, 각 의존성을 명확히
4. 코드는 문학적으로 표현하자 - 사람이 읽기 좋은 코드
```



#### 	코드를 주의깊게 작성하자

```
1. 중복을 줄여라
2. 한 기능만 수행하라 - 여러 기능을 수행하는 메서드는 분할하자
3. 제대로 표현하라 - 의미 있는 네이밍
4. 추상화를 고려하라
```



"프로그램을 단순하게 만드는 것은 **언어**가 아니라, **개발자**다."

## 보이스카우트 규칙

> 캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라

- 잘 짠 코드가 전부는 아니다
- 시간이 지나도 언제나 깨끗하게 유지해야 한다
- 한 번에 많은 시간과 노력을 투자하지 말고, **지속적 개선**을 하자

## 객체지향의 5대 설계 원칙

- SRP(The Single Responsibility Principle): 클래스에는 한 가지 변경 이유만 존재해야 한다
- OCP(The Open Closed Principle): 클래스는 확장에 열려 있어야 하며 변경에 닫혀 있어야 한다
- LSP(The Liskov Substitution Principle): 상속받은 클래스는 기초 클래스를 대체할 수 있어야 한다
- DIP(The Dependency Inversion Principle): 추상화에 의존해야 하며, 구체화에 의존하면 안 된다
- ISP(The Interface Segregation Principle): 클라이언트에 밀접하게 작게 쪼개진 인터페이스를 유지한다

# Chapter 2.의미 있는 이름

## 의도를 분명히 밝혀라

- 좋은 이름을 지으려면 시간이 걸리지만 **좋은 이름으로 절약하는 시간이 훨씬 더 많다**
- 따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말

```java
int d; // 결과 시간(단위: 날짜)

int elapsedTimeInDays;
int daysSinceCreation;
int daysSinceModification;
int fileAgeInDays;
```

- 아래 두 코드를 보자

```java
public List<int[]> getThem() {
    List<int[]> list1 = new ArrayList<int[]>();
    for (int[] x : theList)	// theList엔 뭐가 들었을까?        
        if(x[0] == 4)	// theList 0번째 값을 왜 확인하는걸까?, 값 4는 무슨 의미인가?
            list1.add(x);
    return list1;    // 함수가 반환하는 list1을 어떻게 사용하는가?
}
```

```java
public List<int[]> getFlaggedCells() {
    List<int[]> flaggedCells = new ArrayList<int[]>();
    for (int[] cell : gameBoard)
        if (cell[STATUS_VALUE] == FLAGGED)
            flaggedCells.add(cell);
    return flaggedCells;
}
```

- 연산자 수와 상수 수는 앞의 예와 동일하지만 네이밍만으로 코드는 더욱 명확해졌다
- 여기서 한단계 더 개선해보자

```java
public List<Cell> getFlaggedCells() {	// 칸을 Class화 한다
    List<Cell> flaggedCells = new ArrayList<Cell>();
    for (Cell cell : gameBoard)
        if (cell.isFlagged())	// 명시적인 함수를 사용해 FLAGGED라는 상수를 감춘다
            flaggedCells.add(cell);
    return flaggedCells;
}
```



## 그릇된 정보를 피하라

대표적으로 소문자 `l`과 대문자 `O`가 있다. 이 둘은 각각 숫자 `1`, 숫자 `0`과 비슷한 모양을 갖고 있다

```
left를 줄여 l, object를 줄여 o로 사용하는 예를 많이 봤고 나도 그렇게 써왔는데, 지양해야겠다
```



## 의미 있게 구분하라

```java
public static void copyChars(char a1[], char a2[]) {
    for (int i = 0; i < a1.length; i++){
        a2[i] = a1[i];
    }
}
```

연속적인 숫자를 덧붙인 이름은 의도적 이름과 정 반대다.

이런 이름은 그릇된 정보를 제공하지도 않으며, 아무런 정보를 제공하지 못한다.

아래처럼 바꿔보자

```java
public static void copyChars(char src[], char dest[]){
    for (int i = 0; i < a1.length; i++){
        dest[i] = src[i];
    }
}
```

위 예시 이외에도 `불용어`(의미가 불문명한 용어)를 주의하자

- Product`Info`
- Product`Data`

또한 구분하기 어려운 예시도 참고하자

- `Money`와 `MoneyAmount`
- `customerInfo`와 `customer`
- `accountData`와 `account`
- `theMessage`와 `message`

**읽는 사람이 차이를 알도록** 이름을 짓자

## 발음하기 쉬운 이름을 사용하라

아래 두 코드를 비교해보자

```java
class DtaRcrd102{
    private Date genymdhms;
    private Date modymdhms;
    private final String pszqint = "102";
}
```

```java
class Customer{
    private Date generationTimestamp;
    private Date modificationTimestamp;
    private final String recordId = "102";
}
```

쉽게, 회의 때 해당 변수나 클래스를 발음한다고 생각하면 된다.

프로그래밍은 결국 사회 활동 중 하나다.

## 검색하기 쉬운 이름을 사용하라

```java
for (int j=0; j<34; j++){
    s += (t[j]*4)/5;
}
```

```java
int realDaysPerIdealDay = 4;
const int WORK_DAYS_PER_WEEK = 5;
int sum = 0;
for (int j =0; j<NUMBER_OF_TASKS; j++){
    int realTaskDays = taskEstimate[j] * realDaysPerIdealDay;
    int realTaskWeeks = (realTaskDays / WORK_DAYS_PER_WEEK);
    sum += realTaskWeeks;
}
```

`sum`이 유용하진 않으나 최소한 `검색`이 가능하다. 그리고, 이름이 길어지더라도 최소한 <u>검색이 가능하다</u>는 것을 염두해두자

## 인터페이스 클래스와 구현 클래스

인터페이스 클래스와 구체 클래스 네이밍은 아래와 같이 한다

- ShapeFactory`Imp` - 인터페이스
- `C`ShapeFactory - concrete class

## 클래스 이름

- 명사나 명사구를 사용
- UpperCamelCase
  - **A**ccount
  - **A**ddress**P**arser
- Manager, Processor, Data, Info처럼 `불용어`는 피하자

## 메서드 이름

- 동사나 동사구를 사용
- LowerCalmelCase
  - **p**ost**P**ayment
  - **d**elete**P**age
  - **s**ave
- 접근자, 변경자, 조건자는 javabean 표준에 따라 값 앞에 `get`, `set`, `is`를 붙인다

```java
String name = employee.getName();
customer.setName("mike");
if (paycheck.isPosted())...
```

- 생성자(Constructor)를 오버로딩할 때는 **정적 팩토리 메서드**를 사용한다

```java
Complex fulcrumPoint = Complex.FromRealNumber(23.0);
Complex fulcrumPoint = new Complex(23.0); // 위 방식보단 아래 방식을 사용하자
```



## 한 개념에 한 단어를 사용하라

똑같은 메서드를 클래스마다 `fetch`, `retrieve`, `get`으로 제각각 부르면 혼란스럽다

```
이 코드를 처음 보는 사람은 fetch와 get이 다른가? 왜 따로 구분해놨지? 라고 생각할 수 있다.
```



## 말장난을 하지 마라

집중적인 탐구가 필요한 코드가 아니라 대충 훑어봐도 이해할 코드 작성이 목표다.

- add: 기존 값 두개를 더하거나 이어서 새로운 값을 만듦
- append, insert: 집합에 값 하나를 추가함

위 경우, 일관성을 위해 add를 사용하는 것은 말장난이며 맥락이 다르다. 반드시 구분하자.

의미를 해독할 책임은 독자에게 가선 안되고, **의도를 밝히는 책임을 지니는 저자가 되어야 한다.**

## 해법 영역에서 가져온 이름을 사용하라

> 기술 개념에는 기술 이름이 가장 적합한 선택이다

모든 이름을 `문제 영역(domain)`에서 가져오는 정책은 현명하지 못하다.

## 문제 영역에서 가져온 이름을 사용하라

> 문제 영역 개념과 관련이 깊은 코드라면 문제 영역에서 이름을 가져와야 한다

## 의미 있는 맥락을 추가하라

```java
String firstName;
String lastName;
String street;
String state;
...
```

위 코드를 봤을 때 `state`는 주소라는 사실을 알 수 있다.

```java
String state;
```

하지만 위처럼 `state`하나만 선언되어 있는 경우 주소의 일부라는 사실을 알아채기 힘들다.

```java
String addrState;
```

위 처럼 `addr`이라는 접두어를 추가하면 의미가 보다 명확해진다.

## 불필요한 맥락을 없애라

**의미가 분명한 경우에 한해서** <u>짧은 이름이 긴 이름보다 좋다</u>

고급 휘발유 충전소(Gas Station Deluxe)라는 앱을 짤 때, 모든 클래스 앞에 GSD라는 접두어는 바람직하지 못하다. 너무 포괄적인 개념이며, 중복적이다.

## 결론

사람들이 이름을 바꾸지 않으려는 이유 하나는 다른 개발자가 반대할까 두려워서다.

우리 대다수는 자신이 짠 클래스 이름과 메서드 이름을 모두 암기하지 못한다.

코드를 개선하려는 노력을 중단해서는 안 된다.